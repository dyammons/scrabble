.check_missing <- function(Group, ref) {
# all values in x should be in bins.
    if (is.numeric(ref)) ref = names(ref)
    are_missing = !Group %in% ref
    err = 'Error: Returning missing name(s)...'
    if (any(are_missing)) {
        missing = Group[are_missing]
        stop(cat(c(err, missing), sep = '\n'))
    }
}

.score <- function(mat, groups, controls = NULL, center = FALSE) {

    # Score matrix by groups
    # Scores are the column averages for the subset of rows specified in groups
    # Optional: Control group(s) scores to subtract from the real scores

    # Input check
    .check_missing(Group = unique(unlist(groups)), ref = rownames(mat))
    
    # Score without controls
    if (is.null(controls) | isFALSE(controls)) {
        s.mat = sapply(groups, function(p) colMeans(mat[p, ]))
    }

    # Score with controls
    else {
        if (isTRUE(controls)) {
            # Default control (all rows)
            control.vals = colMeans(mat)
            control.call = quote(control.vals[i])
        }
        else {
            # User-provided controls
            .check_missing(Group = unique(unlist(controls)), ref = rownames(mat))
            control.call = quote(colMeans(mat[controls[[i]], , drop = F]))
        }
        # Score
        groupids = setNames(1:length(groups), names(groups))
        score.call = quote(colMeans(mat[groups[[i]], , drop = F]))
        s.mat = sapply(groupids, function(i) eval(score.call) - eval(control.call))
    }

    # Center?
    if (center) {
        s.mat = scrabble::rowCenter(s.mat)
    }

    return(s.mat)
}


#' @title Score matrix columns for groups of rows 
#' @description Score a matrix by groups of rows. Scores are column averages for the subset of rows specified in a group. Option to generate control group scores to subtract from the real scores. Control groups can either be user-provided or generated from binning of the rows. Similarly, the bins themselves can be user-provided or computed.
#' @param mat a matrix.
#' @param groups a character vector or list of character vectors. Each character vector is a group or signature to score each column against.
#' @param controls. Default: NULL
#' @param center boolean value. Should the resulting score matrix be row-centered? Default: F
#' @param bin.control boolean value. Should control groups be generated by binning the rows? Default: F
#' @param bins a named character vector with as names the rownames and as values the ID of each bin. Default: NULL
#' @param binmat a matrix. If control groups are to be generated from row bins, the user can provide a different matrix of values by which to bin the rownames. The rownames should then obviously match those in <mat>. If NULL, the matrix provided in <mat> will be used. Default: NULL
#' @param nbin numeric value. How many bins should be created? Default: 30
#' @param replace boolean value. Allow bin sampling to be done with replacement. Default: F
#' @param n numeric value for the number of control values/genes to return per value/gene in (each) <group(s)>. Default: 100
#' @return a matrix with as rows the columns of the input matrix and as columns the scores of each group provided in groups. If one group is provided, the matrix returned will have 1 column.
#' @details DETAILS
#' @rdname score
#' @export 
score <- function(mat,
                  groups,
                  controls = NULL,
                  center = F,
                  bin.control = F,
                  bins = NULL,
                  binmat = NULL,
                  nbin = 30,
                  replace = F,
                  n = 100) {

    # Wrapper for .score() with option to first generate control groups
    # Controls are generated with scrabble::binmatch()

    # Generate controls if bins provided
    if (!is.null(bins|binmat)) {
        bin.control = TRUE
    }

    # Except if controls already provided
    if (!is.null(controls)) {
        bin.control = FALSE
    } 

    if (bin.control && is.null(binmat) && all(unique(round(rowMeans(mat), 3)) == 0)) {
        message('Warning: if <mat> is row-centered and <binmat> was not provided, your bins will not be meaningful.')
    }
    # Get bin controls
    if (bin.control) {
        # Make bins if not provided
        if (is.null(bins)) {
            if (!is.null(binmat)) {
                bins = scrabble::bin(mat = binmat, breaks = nbin)
            } else {
                bins = scrabble::bin(mat = mat, breaks = nbin)
            }
        }

        # Make controls for groups using bins
        if (.arg_is_args(arg = groups)) {
            # If <groups> is many:
            controls = sapply(groups,
                              scrabble::binmatch,
                              bins = bins,
                              n = n,
                              replace = replace,
                              simplify = F)
        } else {
            # If <groups> is one:
            controls = scrabble::binmatch(Group = groups,
                                   bins = bins,
                                   n = n,
                                   replace = replace) }
    }

    # Score (with controls or without if controls = NULL)
    .score(mat = mat, groups = groups, controls = controls, center = center)
}
