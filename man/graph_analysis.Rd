% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/graph_analysis.R
\name{graph_analysis}
\alias{graph_analysis}
\title{A Graph-Based Clustering Framework}
\usage{
graph_analysis(mat = NULL, coord.mat = F, knn = F, graph = F,
  clusters = F, k = seq(5, 30, 1), coord.method = "tsne",
  knn.method = "kd_tree", cluster.method = "louvain", ...)
}
\arguments{
\item{mat}{input matrix. Default: NULL}

\item{coord.mat}{coordinates embedding matrix (such as that generated with build_tsne() or build_umap())}

\item{knn}{a boolean value or an object corresponding to FNN::get.knn output or a knn a dataframe with the k-nearest neighbours and corresponding weights (1/1 + the euclidean distance). Default: F}

\item{graph}{igraph graph object. Default: F}

\item{clusters}{a numeric vector (or list of vectors) of cluster IDs with as vector names the corresponding members (or member IDs). Default: F}

\item{k}{a numeric value or vector defining the maximum number or numbers of nearest neighours to search. If a vector is provided, the function will iterate for every value of k. Default: seq(5, 30, 1)}

\item{coord.method}{character string defining the dimension-reduction method used. One of 'umap' or 'tsne', calling umap::umap or Rtsne::Rtsne, respectively. Default: 'tsne'}

\item{knn.method}{nearest neighbour searching algorithm. One of kd_tree, cover_tree, CR, brute. Default: 'kd_tree'}

\item{cluster.method}{a character string, one of 'louvain' or 'hierarchical', defining the clustering method used. Default: 'louvain'}

\item{...}{other arguments passed to umap::umap or Rtsne::Rtsne.}
}
\value{
an object if one of coord.mat, knn, graph or clusters is set to TRUE, otherwise a list containing each of the objects computed and the configuration values. If multiple k's are desired, then the knn, graph and clusters objects will each be lists of the same lengths as there are ks.
}
\description{
Graph-based clustering consisting of the following steps: (1) build a coordinates embedding matrix (e.g. with tSNE, UMAP, MDS). (2) Search for k-nearest neighbours and build a dataframe with resulting neighbours and their weights. (3) Build a graph from the k-nearest neighbours. (4) Cluster the graph with one of a number of methods, e.g. Louvain clustering. (5) Return the clusters. If any of the arguments corresponding to each of these steps is set to TRUE, the function will stop after the relevant computation and return the object set to TRUE. Alternatively if set to FALSE, the computation will continue, unless an earlier step was set to TRUE. If instead, for any of these objects, the relevant object was provided, this object will be used instead of computed.
}
